### 几何体判重

本题的关键在于**几何体判重**，在**操作4**新增几何体以及**操作5**取并集的时候都需要进行判重操作。

最重要的是equals函数，包括两个步骤：1.判断是否为同一类 2.判断各项属性是否相同

对于1，使用instanceof无法精确判断，比如Cube对象和CuboidBox类会判断为True，而讨论区里介绍的getClass()我使用时出现了一些问题（可能是自己不太会用）。我的解决方案是给顶层接口/抽象类增加一个type()方法返回字符串，然后在子类分别实现"1"、"1.1.1"等返回值，注意子类要**重写**父类的type()。

对于2，首先要在顶层接口/抽象类增加equals(Shape other)方法，其中Shape为顶层接口类型，然后各个子类分别实现/重写，先判断type()是否相等，再判断各项属性是否相同。注意**后者不能直接调用父类的equals()方法**，但写子类getLength()方法时时可以调用父类的getLength()等。写的过程中需要使用**类型转换**，比如对于Cube可以写 return this.getLength() == ((Cube) other).getLength()，否则编译器认为other不具有getLength()方法。

### 其他若干小坑点

1. 字符串比较不应该用==，应该用equalsto()，这个idea应该会有warning。讨论区其他帖子已提及。

2. 判定重复后不应修改体积和、修改最大体积、添加至几何体集合，而应该直接break。

3. 对于空集，操作1和2需要报错，操作3应输出0.

4. 如果使用list储存几何体集合（例如二维list或list嵌套自定义类等），数组大小不能只开n个，因为取并集会增加集合个数导致越界。实测2n可以满足要求。当然最好的方法肯定是ArrayList或者HashSet。

5. 数据点中包括**体积为0的几何体**。这就有两个坑点：1.操作4向空集添加体积为0的几何体，此时操作2应输出该几何体的信息 2.操作5**将空集与体积为0的几何体合并**，此时操作2也应输出后者的信息，如果在数据点7或8出现null则可能是此情况。
6. 指导书中提到的几种情况（如棱长为1,1,1的长方体和棱长为1的正方体不同、棱长为1.0和棱长为1的正方体相同），注意后者否定了讨论区中通过字符串比较来判重的方法（如"1.1.1 1.0"和"1.1.1 1"）

### debug小技巧

数据点7和8提供了报错信息以及标准输入输出，可以下载下来比对，不过根据输出寻找对应输入比较花费时间，应优先尝试自己设计测试数据。注意标准输出=控制台输出=stdout**≠期望输出**

根据报错进行推测，如null对应空集与体积为0几何体合并，期望276.0825得到284.0825对应棱长为2的立方体判重，期望28.56得到41.13对应体积为4π的圆台/圆柱/圆锥判重，从而可以自己设计数据点进行测试。

多看idea的warning信息，在每个文件用shift+F2查看。